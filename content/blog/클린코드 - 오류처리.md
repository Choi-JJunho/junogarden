---
title: 클린코드 - 오류처리
description: 오류처리를 보다 깔끔하게 하는 방식을 알아보자
date: 2022-11-28T12:05:50.338Z
tags:
  - 7장
  - 오류처리
  - 클린 코드
---
# 서론

에외처리를 보다 깔끔하게 작성하기위한 방향을 몇가지 알아보자

# 오류코드보다는 예외처리를 하자

모든 예외상황에 대해 
`if... log(ErrorCode)... if... log(ErrorCode)... `
이렇게 처리해버리면 코드가 금방 복잡해지는것을 알 수 있다.

그냥 예외를 던져서 처리하도록 하자.

# try - catch - finally를 사용하자

1. 예외를 일으키는 테스트케이스를 작성한다.
2. 테스트를 통과하도록 구문을 작성한다.
3. 자연스럽게 try블록 내부의 트랜잭션 구문을 고려하게된다.

# 미확인(Unchecked) 예외를 사용하자

Checked Exception을 사용하면 다음과 같은 문제가 발생한다.

해당 함수를 호출하는 모든 함수가 catch 블록에서 새로운 예외를 처리하거나 선언부에 throw절을 추가해야한다. 즉 최하위 단계부터 최상위 단계까지 연쇄적인 수정이 일어난다.


때문에 Checked Exception은 OCP(개방폐쇄원칙)을 위반한다.

> Checked Exception : RuntimeExceeption을 상속하지 않는 예외로 꼭 처리해야하는 예외다.
UnChecked Exception : RuntimeExceeption을 상속하는 예외로 꼭 처리하지 않아도 되는 예외다.
[참고 블로그](https://madplay.github.io/post/java-checked-unchecked-exceptions)


# 예외에 의미를 제공하자

자바는 모든 예외에 호출 스택을 제공하지만 실패한 코드의 의도를 파악하기위해서는 충분한 의미를 제공해줄 필요가 있다.

> 여담이지만 [우아한 테크코스 프리코스 4주차](https://github.com/woowacourse-precourse/java-bridge)에서 주어진 조건중 다음과 같은 조건이 있었다.
![](/images/be5ebac6-076d-42e8-9657-70431c57c32f-image.png)
아마 이 장에서 설명하는 예외에 의미를 제공하라는 의도를 내포하고 있었던 것 같다.

# 호출자를 고려해 예외클래스를 정의해라

위 문장을 처음 읽어봤을 때는 한번에 이해하기 어려웠다.
다음 예시를 보면 이해가 될 것이다.

``` java
PortLibrary port = new PortLibrary(12);

try {
	port.open();
} catch (DeviceSomthingException e) {
	e.printStackTrace();
} catch (PortWrongException e) {
	e.doSomething();
} ...

```

위와같이 외부 라이브러리를 사용할 경우 나올 수 있는 모든 예외에 대해 처리해주려다보면 본래의 로직을 방해하게 될 것이다.

이러한 부분은 해당 라이브러리를 한번 더 wrapping하여 사용하는 방법을 생각해 볼 수 있겠다.
``` java
public class LocalPort {
	private PortLibrary portLibrary;

	public LocalPort(int portNumber) {
		this.portLibrary = new PortLibrary(portNumber);
	}

	public void open() {
		try {
			port.open();
		} catch (DeviceSomthingException e) {
			e.printStackTrace();
		} catch (PortWrongException e) {
			e.doSomething();
		} ...
	}
```

위와같이 외부 라이브러리를 한번 더 감싸주면 라이브러리를 교체할때의 비용도 훨씬 줄어들고, 테스트 시 외부 라이브러리가 아닌 임의의 값을 넣어줄 수 있기 때문에 테스트하기도 편해진다. 


## 정상흐름을 정의하라
클래스를 만들거나 객체를 조작해 특수한 상황을 처리하는 방식을 특수사례패턴 이라고한다.
특수사례패턴은 반환할 값이 없을 때 기본값을 반환하는 방식을 말한다.
클래스나 객체가 예외상황을 캡슐화 해서 처리하게 둘 수 있다.

## null을 반환하지마라

여기까지 클린코드를 읽었으면 뭔가 당연하게 끔 여겨지기도 하지만 왜 당연한건지 이유를 들어보면 좋을 것 같다.
null을 반환하게된다면 해당 로직을 사용하는 클라이언트 쪽은 추가로 null에 대한 처리를 해줘야만 하기 때문에 자칫하면 복잡해질 수 있기 때문에 null은 반환하지 않는것이 좋다.

## null을 전달하지마라

간혹 사용자가 null을 전달하면 어떡하지..? 라는 마음에 인자로 들어오는 값에 대한 Null check를 하는 경우가 있다.
이렇게되면 Null을 가질수 있는 인자를 가진 모든 함수들에서 Null Check가 이뤄져야만 할 것이다.

이러한 부분은 중복코드 뿐만 아니라 의미 없는 코드를 대량생산해버리게된다.
책에서는 이렇게 들어오는 인자에 대한 부분은 정책상으로 규제를 걸어놓는것이 올바른 방향이라고 설명하고있다.

# 후기

외부 라이브러리를 한번 더 wrapping하는 부분에서 이마를 탁 쳤다..ㅋㅋㅋㅋ

# Reference

Clean Code(클린 코드) | 로버트 C. 마틴

![](/images/e2cb4fe7-dfb4-4336-a985-a4c15608449d-image.png)
